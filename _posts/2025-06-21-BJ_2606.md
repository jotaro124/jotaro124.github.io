---
layout: single
title: "백준 2606 바이러스 (DFS)"
categories: BFSsDFS
toc: true
toc_sticky : true
sidebar:
     nav: "docs"
---

# 문제
[https://www.acmicpc.net/problem/2606](https://www.acmicpc.net/problem/2606)

## 문제설명
신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.

예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.

![sample1](..\..\images\2025-06-21-BJ_2606\sample1.png)

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.
## 입력
첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.
## 출력
1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

## 예제 입력1
~~~
7
6
1 2
2 3
1 5
5 2
5 6
4 7
~~~

## 예제 출력1
~~~
4
~~~

<br>

# 문제풀이
## 문제헤설
그래프를 표현하고 DFS를 통해서 감염된 컴퓨터를 측정하는 문제

## 생각한 것
- 그래프 표현 방법
- DFS 방법

<br>

# 그래프 표현
그래프는 그림을 이용하여 표현하는 것으로 가장 자연스럽고 이해하기에 가장 쉬운 방법이다. 그러나 컴퓨터는 그림으로 표현된 정보를 이용할 수 없기 때문에 인접 행렬이나 인접 리스트에 의해 표현된다. 그래서 그래프를 표현할 방법으로 **인접 행렬**를 사용할 것이고 **2차원 배열**로 인접 행렬을 표현할 것이다.

- 원래 정점의 개수가 N이면 N X N 행렬로 표현한다.
- 여기서 고려할 점은 배열 크기가 N이면 인덱스는 0 ~ N-1로 표현된다.
- 하지만 문제에서 **"1번부터 차례대로 번호가 매겨진다."**라고 적혀있기 때문에 인덱스 0을 제외하고 1부터 N까지 표현하기 위해 배열 크기를 N+1로 한다.
- 그리고 문제에서 "컴퓨터의 수는 **100이하**인 양의 정수"이기 때문에 배열 크기는 **101**이다.

~~~c++
int map[101][101]; // 네트워크 표현
int visited[101]; // 현재 정점 방문 체크

// ~~중략~~ 

// 간선 연결
for (int i = 0; i < M; i++) {
		// 연결 정점 입력
		cin >> v1 >> v2;

		map[v1][v2] = 1;
		map[v2][v1] = 1;
}
~~~

# DFS
1. 현재 방문한 노드를 기록한다.
2. 1~N까지 정점 방문한다.
3. 현재 정점과 연결되어있고, 방문한적 없는 정점 탐색

<br>

# 전체코드
## DFS로 풀이
~~~c++
#include <iostream>

using namespace std;

int map[101][101]; // 네트워크 표현
int visited[101]; // 현재 정점 방문 체크
int N; // 컴퓨터 수
int M; // 간선의 수
int result = 0; // 감연된 컴퓨터 수

// DFS 함수
void DFS(int V) {
	visited[V] = 1; // 현재 방문 기록
	// 1~N까지 정점 방문
	// 현재 정점과 연결되어있고, 방문한적 없는 정점 탐색
	for (int i = 1; i <= N; i++) {
		if (map[V][i] == 1 && visited[i] == 0) {
			result = result + 1;
			DFS(i);
		}
	}
}

int main() {
	int v1, v2; // 연결 정점

	// 컴퓨터 수, 간선 수 입력
	cin >> N>>M; 

	for (int i = 0; i < M; i++) {
		// 연결 정점 입력
		cin >> v1 >> v2;

		map[v1][v2] = 1;
		map[v2][v1] = 1;
	}

	// DFS 사용
	DFS(1);
	cout << result;

	return 0;
}
~~~

## BFS로 풀이
~~~c++
#include <iostream>
#include <queue>
using namespace std;

int map[101][101]; // 네트워크 표현
int visited[101]; // 현재 정점 방문 체크
int N; // 컴퓨터 수
int M; // 간선의 수
int result = 0; // 감연된 컴퓨터 수

// BFS 함수
void BFS(int V) {
	queue<int> q; // BFS에 사용할 큐 생성
	q.push(V);
	
	while (!q.empty()) {
		int next = q.front();
		visited[next] = 1;
		q.pop();

        // 1~N까지 정점 방문
	    // 현재 정점과 연결되어있고, 방문한적 없는 정점 탐색
		for (int i = 1; i <= N; i++) {
			if (map[next][i] == 1 && visited[i] == 0) {
				q.push(i);
				visited[i] = 1;
				result = result + 1;
			}
		}
	}
}

int main() {
	int v1, v2; // 연결 정점

	// 컴퓨터 수, 간선 수 입력
	cin >> N>>M; 

	for (int i = 0; i < M; i++) {
		// 연결 정점 입력
		cin >> v1 >> v2;

		map[v1][v2] = 1;
		map[v2][v1] = 1;
	}

	// BFS 사용
	BFS(1);
	cout << result;

	return 0;
}
~~~

<br>

# 참조
- C로 배우는 쉬운 자료구조 4탄, 이지영, 한빛아카데미, 2022
- 4차 산업혁명 시대의 이산수학, 김대수, 생능출판, 2019
- [[C++] 백준 2606 - 바이러스](https://velog.io/@hyunjoon0803/C-%EB%B0%B1%EC%A4%80-2606-%EB%B0%94%EC%9D%B4%EB%9F%AC%EC%8A%A4)